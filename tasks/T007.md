# T007: Form Components

## Overview

**Task ID**: T007
**Phase**: 2 - Core Components
**Priority**: High
**Dependencies**: T001, T003
**Estimated Complexity**: Medium

## Objective

Create reusable form components including input fields, textarea, select, checkbox, and a contact form component. These will be used on the Contact and Book Consultation pages.

---

## Prerequisites

Before starting this task:
1. Read `CLAUDE.md` for agent rules
2. Check `EXECUTION.md` - Ensure T001 and T003 are `completed`
3. Mark this task as `in_progress` in `EXECUTION.md`
4. Read `SHARED_NOTES.md` for any relevant notes

---

## File Ownership

```
CREATE:
- src/components/Forms/Input/index.tsx
- src/components/Forms/Input/styles.ts
- src/components/Forms/Input/Input.test.tsx
- src/components/Forms/TextArea/index.tsx
- src/components/Forms/TextArea/styles.ts
- src/components/Forms/TextArea/TextArea.test.tsx
- src/components/Forms/Select/index.tsx
- src/components/Forms/Select/styles.ts
- src/components/Forms/Select/Select.test.tsx
- src/components/Forms/FormField/index.tsx
- src/components/Forms/FormField/styles.ts
- src/components/Forms/FormField/FormField.test.tsx
- src/components/Forms/index.ts
- src/lib/validation.ts
- src/__tests__/lib/validation.test.ts
```

---

## Detailed Requirements

### 1. Input Component

#### `src/components/Forms/Input/index.tsx`
```typescript
'use client';

import React, { forwardRef } from 'react';
import { InputWrapper, StyledInput, InputIcon } from './styles';

export interface InputProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'size'> {
  error?: boolean;
  icon?: React.ReactNode;
  inputSize?: 'sm' | 'md' | 'lg';
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ error = false, icon, inputSize = 'md', className, ...props }, ref) => {
    return (
      <InputWrapper className={className}>
        {icon && <InputIcon $size={inputSize}>{icon}</InputIcon>}
        <StyledInput
          ref={ref}
          $error={error}
          $hasIcon={!!icon}
          $size={inputSize}
          data-testid="input"
          {...props}
        />
      </InputWrapper>
    );
  }
);

Input.displayName = 'Input';

export default Input;
```

#### `src/components/Forms/Input/styles.ts`
```typescript
import styled, { css } from 'styled-components';
import { inputReset } from '@/styles';

export const InputWrapper = styled.div`
  position: relative;
  width: 100%;
`;

interface InputIconProps {
  $size: 'sm' | 'md' | 'lg';
}

export const InputIcon = styled.span<InputIconProps>`
  position: absolute;
  left: ${({ theme }) => theme.spacing[4]};
  top: 50%;
  transform: translateY(-50%);
  color: ${({ theme }) => theme.colors.mediumGray};
  display: flex;
  align-items: center;
  pointer-events: none;
`;

interface StyledInputProps {
  $error: boolean;
  $hasIcon: boolean;
  $size: 'sm' | 'md' | 'lg';
}

const sizeStyles = {
  sm: css`
    padding: ${({ theme }) => `${theme.spacing[2]} ${theme.spacing[3]}`};
    font-size: ${({ theme }) => theme.fontSizes.sm};
  `,
  md: css`
    padding: ${({ theme }) => `${theme.spacing[3]} ${theme.spacing[4]}`};
    font-size: ${({ theme }) => theme.fontSizes.base};
  `,
  lg: css`
    padding: ${({ theme }) => `${theme.spacing[4]} ${theme.spacing[5]}`};
    font-size: ${({ theme }) => theme.fontSizes.md};
  `,
};

export const StyledInput = styled.input<StyledInputProps>`
  ${inputReset}
  width: 100%;
  background-color: ${({ theme }) => theme.colors.backgroundLight};
  border: 2px solid transparent;
  border-radius: ${({ theme }) => theme.borderRadius.lg};
  color: ${({ theme }) => theme.colors.white};
  transition: all ${({ theme }) => theme.transitions.fast};

  ${({ $size }) => sizeStyles[$size]}

  ${({ $hasIcon }) =>
    $hasIcon &&
    css`
      padding-left: ${({ theme }) => theme.spacing[12]};
    `}

  &::placeholder {
    color: ${({ theme }) => theme.colors.darkGray};
  }

  &:hover:not(:disabled) {
    border-color: ${({ theme }) => theme.colors.darkGray};
  }

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colors.primary};
    box-shadow: 0 0 0 3px rgba(236, 255, 136, 0.1);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  ${({ $error }) =>
    $error &&
    css`
      border-color: ${({ theme }) => theme.colors.error};

      &:focus {
        border-color: ${({ theme }) => theme.colors.error};
        box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.1);
      }
    `}
`;
```

#### `src/components/Forms/Input/Input.test.tsx`
```typescript
import React from 'react';
import { render, screen, fireEvent } from '@/__tests__/test-utils';
import Input from './index';

describe('Input', () => {
  it('should render input', () => {
    render(<Input placeholder="Enter text" />);
    expect(screen.getByTestId('input')).toBeInTheDocument();
  });

  it('should handle value changes', () => {
    const handleChange = jest.fn();
    render(<Input onChange={handleChange} />);
    fireEvent.change(screen.getByTestId('input'), { target: { value: 'test' } });
    expect(handleChange).toHaveBeenCalled();
  });

  it('should show placeholder', () => {
    render(<Input placeholder="Test placeholder" />);
    expect(screen.getByPlaceholderText('Test placeholder')).toBeInTheDocument();
  });

  it('should be disabled when disabled prop is true', () => {
    render(<Input disabled />);
    expect(screen.getByTestId('input')).toBeDisabled();
  });

  it('should apply error styles when error prop is true', () => {
    render(<Input error />);
    expect(screen.getByTestId('input')).toBeInTheDocument();
  });

  it('should render with icon', () => {
    render(<Input icon={<span data-testid="icon">üîç</span>} />);
    expect(screen.getByTestId('icon')).toBeInTheDocument();
  });

  it('should support different sizes', () => {
    const { rerender } = render(<Input inputSize="sm" />);
    expect(screen.getByTestId('input')).toBeInTheDocument();

    rerender(<Input inputSize="lg" />);
    expect(screen.getByTestId('input')).toBeInTheDocument();
  });
});
```

### 2. TextArea Component

#### `src/components/Forms/TextArea/index.tsx`
```typescript
'use client';

import React, { forwardRef } from 'react';
import { StyledTextArea } from './styles';

export interface TextAreaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  error?: boolean;
  resize?: 'none' | 'vertical' | 'horizontal' | 'both';
}

const TextArea = forwardRef<HTMLTextAreaElement, TextAreaProps>(
  ({ error = false, resize = 'vertical', className, ...props }, ref) => {
    return (
      <StyledTextArea
        ref={ref}
        $error={error}
        $resize={resize}
        className={className}
        data-testid="textarea"
        {...props}
      />
    );
  }
);

TextArea.displayName = 'TextArea';

export default TextArea;
```

#### `src/components/Forms/TextArea/styles.ts`
```typescript
import styled, { css } from 'styled-components';
import { inputReset } from '@/styles';

interface StyledTextAreaProps {
  $error: boolean;
  $resize: 'none' | 'vertical' | 'horizontal' | 'both';
}

export const StyledTextArea = styled.textarea<StyledTextAreaProps>`
  ${inputReset}
  width: 100%;
  min-height: 120px;
  padding: ${({ theme }) => theme.spacing[4]};
  background-color: ${({ theme }) => theme.colors.backgroundLight};
  border: 2px solid transparent;
  border-radius: ${({ theme }) => theme.borderRadius.lg};
  color: ${({ theme }) => theme.colors.white};
  font-size: ${({ theme }) => theme.fontSizes.base};
  line-height: ${({ theme }) => theme.lineHeights.relaxed};
  transition: all ${({ theme }) => theme.transitions.fast};
  resize: ${({ $resize }) => $resize};

  &::placeholder {
    color: ${({ theme }) => theme.colors.darkGray};
  }

  &:hover:not(:disabled) {
    border-color: ${({ theme }) => theme.colors.darkGray};
  }

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colors.primary};
    box-shadow: 0 0 0 3px rgba(236, 255, 136, 0.1);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  ${({ $error }) =>
    $error &&
    css`
      border-color: ${({ theme }) => theme.colors.error};

      &:focus {
        border-color: ${({ theme }) => theme.colors.error};
        box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.1);
      }
    `}
`;
```

#### `src/components/Forms/TextArea/TextArea.test.tsx`
```typescript
import React from 'react';
import { render, screen, fireEvent } from '@/__tests__/test-utils';
import TextArea from './index';

describe('TextArea', () => {
  it('should render textarea', () => {
    render(<TextArea placeholder="Enter text" />);
    expect(screen.getByTestId('textarea')).toBeInTheDocument();
  });

  it('should handle value changes', () => {
    const handleChange = jest.fn();
    render(<TextArea onChange={handleChange} />);
    fireEvent.change(screen.getByTestId('textarea'), { target: { value: 'test' } });
    expect(handleChange).toHaveBeenCalled();
  });

  it('should be disabled when disabled prop is true', () => {
    render(<TextArea disabled />);
    expect(screen.getByTestId('textarea')).toBeDisabled();
  });

  it('should apply error styles when error prop is true', () => {
    render(<TextArea error />);
    expect(screen.getByTestId('textarea')).toBeInTheDocument();
  });
});
```

### 3. Select Component

#### `src/components/Forms/Select/index.tsx`
```typescript
'use client';

import React, { forwardRef } from 'react';
import { SelectWrapper, StyledSelect, SelectIcon } from './styles';

export interface SelectOption {
  value: string;
  label: string;
  disabled?: boolean;
}

export interface SelectProps extends Omit<React.SelectHTMLAttributes<HTMLSelectElement>, 'size'> {
  options: SelectOption[];
  placeholder?: string;
  error?: boolean;
  selectSize?: 'sm' | 'md' | 'lg';
}

const Select = forwardRef<HTMLSelectElement, SelectProps>(
  ({ options, placeholder, error = false, selectSize = 'md', className, ...props }, ref) => {
    return (
      <SelectWrapper className={className}>
        <StyledSelect
          ref={ref}
          $error={error}
          $size={selectSize}
          data-testid="select"
          {...props}
        >
          {placeholder && (
            <option value="" disabled>
              {placeholder}
            </option>
          )}
          {options.map((option) => (
            <option key={option.value} value={option.value} disabled={option.disabled}>
              {option.label}
            </option>
          ))}
        </StyledSelect>
        <SelectIcon>
          <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
            <path d="M6 8L2 4h8L6 8z" />
          </svg>
        </SelectIcon>
      </SelectWrapper>
    );
  }
);

Select.displayName = 'Select';

export default Select;
```

#### `src/components/Forms/Select/styles.ts`
```typescript
import styled, { css } from 'styled-components';

export const SelectWrapper = styled.div`
  position: relative;
  width: 100%;
`;

interface StyledSelectProps {
  $error: boolean;
  $size: 'sm' | 'md' | 'lg';
}

const sizeStyles = {
  sm: css`
    padding: ${({ theme }) => `${theme.spacing[2]} ${theme.spacing[8]} ${theme.spacing[2]} ${theme.spacing[3]}`};
    font-size: ${({ theme }) => theme.fontSizes.sm};
  `,
  md: css`
    padding: ${({ theme }) => `${theme.spacing[3]} ${theme.spacing[10]} ${theme.spacing[3]} ${theme.spacing[4]}`};
    font-size: ${({ theme }) => theme.fontSizes.base};
  `,
  lg: css`
    padding: ${({ theme }) => `${theme.spacing[4]} ${theme.spacing[12]} ${theme.spacing[4]} ${theme.spacing[5]}`};
    font-size: ${({ theme }) => theme.fontSizes.md};
  `,
};

export const StyledSelect = styled.select<StyledSelectProps>`
  appearance: none;
  width: 100%;
  background-color: ${({ theme }) => theme.colors.backgroundLight};
  border: 2px solid transparent;
  border-radius: ${({ theme }) => theme.borderRadius.lg};
  color: ${({ theme }) => theme.colors.white};
  cursor: pointer;
  transition: all ${({ theme }) => theme.transitions.fast};

  ${({ $size }) => sizeStyles[$size]}

  &:hover:not(:disabled) {
    border-color: ${({ theme }) => theme.colors.darkGray};
  }

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colors.primary};
    box-shadow: 0 0 0 3px rgba(236, 255, 136, 0.1);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  option {
    background-color: ${({ theme }) => theme.colors.backgroundLight};
    color: ${({ theme }) => theme.colors.white};
  }

  ${({ $error }) =>
    $error &&
    css`
      border-color: ${({ theme }) => theme.colors.error};
    `}
`;

export const SelectIcon = styled.span`
  position: absolute;
  right: ${({ theme }) => theme.spacing[4]};
  top: 50%;
  transform: translateY(-50%);
  color: ${({ theme }) => theme.colors.mediumGray};
  pointer-events: none;
`;
```

#### `src/components/Forms/Select/Select.test.tsx`
```typescript
import React from 'react';
import { render, screen, fireEvent } from '@/__tests__/test-utils';
import Select from './index';

const options = [
  { value: 'option1', label: 'Option 1' },
  { value: 'option2', label: 'Option 2' },
  { value: 'option3', label: 'Option 3' },
];

describe('Select', () => {
  it('should render select', () => {
    render(<Select options={options} />);
    expect(screen.getByTestId('select')).toBeInTheDocument();
  });

  it('should render all options', () => {
    render(<Select options={options} />);
    options.forEach((option) => {
      expect(screen.getByText(option.label)).toBeInTheDocument();
    });
  });

  it('should render placeholder when provided', () => {
    render(<Select options={options} placeholder="Select an option" />);
    expect(screen.getByText('Select an option')).toBeInTheDocument();
  });

  it('should handle value changes', () => {
    const handleChange = jest.fn();
    render(<Select options={options} onChange={handleChange} />);
    fireEvent.change(screen.getByTestId('select'), { target: { value: 'option2' } });
    expect(handleChange).toHaveBeenCalled();
  });

  it('should be disabled when disabled prop is true', () => {
    render(<Select options={options} disabled />);
    expect(screen.getByTestId('select')).toBeDisabled();
  });
});
```

### 4. FormField Component (Label + Input wrapper)

#### `src/components/Forms/FormField/index.tsx`
```typescript
'use client';

import React from 'react';
import { FieldWrapper, Label, ErrorMessage, HelperText } from './styles';

export interface FormFieldProps {
  label: string;
  htmlFor: string;
  error?: string;
  helperText?: string;
  required?: boolean;
  children: React.ReactNode;
}

const FormField: React.FC<FormFieldProps> = ({
  label,
  htmlFor,
  error,
  helperText,
  required = false,
  children,
}) => {
  return (
    <FieldWrapper data-testid="form-field">
      <Label htmlFor={htmlFor}>
        {label}
        {required && <span aria-hidden="true"> *</span>}
      </Label>
      {children}
      {error && <ErrorMessage role="alert">{error}</ErrorMessage>}
      {!error && helperText && <HelperText>{helperText}</HelperText>}
    </FieldWrapper>
  );
};

export default FormField;
```

#### `src/components/Forms/FormField/styles.ts`
```typescript
import styled from 'styled-components';
import { flexColumn } from '@/styles';

export const FieldWrapper = styled.div`
  ${flexColumn}
  gap: ${({ theme }) => theme.spacing[2]};
  width: 100%;
`;

export const Label = styled.label`
  font-size: ${({ theme }) => theme.fontSizes.sm};
  font-weight: ${({ theme }) => theme.fontWeights.medium};
  color: ${({ theme }) => theme.colors.lightGray};

  span {
    color: ${({ theme }) => theme.colors.error};
  }
`;

export const ErrorMessage = styled.span`
  font-size: ${({ theme }) => theme.fontSizes.sm};
  color: ${({ theme }) => theme.colors.error};
`;

export const HelperText = styled.span`
  font-size: ${({ theme }) => theme.fontSizes.sm};
  color: ${({ theme }) => theme.colors.darkGray};
`;
```

#### `src/components/Forms/FormField/FormField.test.tsx`
```typescript
import React from 'react';
import { render, screen } from '@/__tests__/test-utils';
import FormField from './index';

describe('FormField', () => {
  it('should render form field with label', () => {
    render(
      <FormField label="Email" htmlFor="email">
        <input id="email" />
      </FormField>
    );
    expect(screen.getByText('Email')).toBeInTheDocument();
  });

  it('should show required indicator', () => {
    render(
      <FormField label="Email" htmlFor="email" required>
        <input id="email" />
      </FormField>
    );
    expect(screen.getByText('*')).toBeInTheDocument();
  });

  it('should show error message', () => {
    render(
      <FormField label="Email" htmlFor="email" error="Email is required">
        <input id="email" />
      </FormField>
    );
    expect(screen.getByText('Email is required')).toBeInTheDocument();
  });

  it('should show helper text when no error', () => {
    render(
      <FormField label="Email" htmlFor="email" helperText="Enter your email">
        <input id="email" />
      </FormField>
    );
    expect(screen.getByText('Enter your email')).toBeInTheDocument();
  });

  it('should not show helper text when error is present', () => {
    render(
      <FormField label="Email" htmlFor="email" error="Error" helperText="Helper">
        <input id="email" />
      </FormField>
    );
    expect(screen.queryByText('Helper')).not.toBeInTheDocument();
    expect(screen.getByText('Error')).toBeInTheDocument();
  });
});
```

### 5. Validation Utilities

#### `src/lib/validation.ts`
```typescript
export interface ValidationRule {
  validate: (value: string) => boolean;
  message: string;
}

export const required = (message = 'This field is required'): ValidationRule => ({
  validate: (value) => value.trim().length > 0,
  message,
});

export const email = (message = 'Please enter a valid email'): ValidationRule => ({
  validate: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
  message,
});

export const minLength = (min: number, message?: string): ValidationRule => ({
  validate: (value) => value.length >= min,
  message: message || `Must be at least ${min} characters`,
});

export const maxLength = (max: number, message?: string): ValidationRule => ({
  validate: (value) => value.length <= max,
  message: message || `Must be no more than ${max} characters`,
});

export const phone = (message = 'Please enter a valid phone number'): ValidationRule => ({
  validate: (value) => /^[\d\s\-+()]+$/.test(value) && value.replace(/\D/g, '').length >= 10,
  message,
});

export const url = (message = 'Please enter a valid URL'): ValidationRule => ({
  validate: (value) => {
    try {
      new URL(value);
      return true;
    } catch {
      return false;
    }
  },
  message,
});

export const validate = (value: string, rules: ValidationRule[]): string | null => {
  for (const rule of rules) {
    if (!rule.validate(value)) {
      return rule.message;
    }
  }
  return null;
};

export const validateForm = <T extends Record<string, string>>(
  values: T,
  validationRules: Partial<Record<keyof T, ValidationRule[]>>
): Partial<Record<keyof T, string>> => {
  const errors: Partial<Record<keyof T, string>> = {};

  for (const [field, rules] of Object.entries(validationRules)) {
    if (rules) {
      const error = validate(values[field as keyof T] || '', rules as ValidationRule[]);
      if (error) {
        errors[field as keyof T] = error;
      }
    }
  }

  return errors;
};
```

#### `src/__tests__/lib/validation.test.ts`
```typescript
import {
  required,
  email,
  minLength,
  maxLength,
  phone,
  url,
  validate,
  validateForm,
} from '@/lib/validation';

describe('Validation utilities', () => {
  describe('required', () => {
    it('should fail for empty string', () => {
      const rule = required();
      expect(rule.validate('')).toBe(false);
      expect(rule.validate('   ')).toBe(false);
    });

    it('should pass for non-empty string', () => {
      const rule = required();
      expect(rule.validate('test')).toBe(true);
    });
  });

  describe('email', () => {
    it('should fail for invalid emails', () => {
      const rule = email();
      expect(rule.validate('invalid')).toBe(false);
      expect(rule.validate('test@')).toBe(false);
      expect(rule.validate('@test.com')).toBe(false);
    });

    it('should pass for valid emails', () => {
      const rule = email();
      expect(rule.validate('test@example.com')).toBe(true);
      expect(rule.validate('test.name@example.co.uk')).toBe(true);
    });
  });

  describe('minLength', () => {
    it('should fail for strings shorter than minimum', () => {
      const rule = minLength(5);
      expect(rule.validate('test')).toBe(false);
    });

    it('should pass for strings equal to or longer than minimum', () => {
      const rule = minLength(5);
      expect(rule.validate('tests')).toBe(true);
      expect(rule.validate('testing')).toBe(true);
    });
  });

  describe('maxLength', () => {
    it('should fail for strings longer than maximum', () => {
      const rule = maxLength(5);
      expect(rule.validate('testing')).toBe(false);
    });

    it('should pass for strings equal to or shorter than maximum', () => {
      const rule = maxLength(5);
      expect(rule.validate('tests')).toBe(true);
      expect(rule.validate('test')).toBe(true);
    });
  });

  describe('phone', () => {
    it('should fail for invalid phone numbers', () => {
      const rule = phone();
      expect(rule.validate('123')).toBe(false);
      expect(rule.validate('not-a-phone')).toBe(false);
    });

    it('should pass for valid phone numbers', () => {
      const rule = phone();
      expect(rule.validate('1234567890')).toBe(true);
      expect(rule.validate('+1 (555) 123-4567')).toBe(true);
    });
  });

  describe('url', () => {
    it('should fail for invalid URLs', () => {
      const rule = url();
      expect(rule.validate('not-a-url')).toBe(false);
      expect(rule.validate('www.example.com')).toBe(false);
    });

    it('should pass for valid URLs', () => {
      const rule = url();
      expect(rule.validate('https://example.com')).toBe(true);
      expect(rule.validate('http://localhost:3000')).toBe(true);
    });
  });

  describe('validate', () => {
    it('should return first error message', () => {
      const rules = [required(), minLength(5)];
      expect(validate('', rules)).toBe('This field is required');
      expect(validate('test', rules)).toBe('Must be at least 5 characters');
    });

    it('should return null for valid input', () => {
      const rules = [required(), minLength(5)];
      expect(validate('testing', rules)).toBeNull();
    });
  });

  describe('validateForm', () => {
    it('should validate multiple fields', () => {
      const values = { email: '', name: 'ab' };
      const rules = {
        email: [required(), email()],
        name: [required(), minLength(3)],
      };
      const errors = validateForm(values, rules);
      expect(errors.email).toBe('This field is required');
      expect(errors.name).toBe('Must be at least 3 characters');
    });

    it('should return empty object for valid form', () => {
      const values = { email: 'test@example.com', name: 'John' };
      const rules = {
        email: [required(), email()],
        name: [required(), minLength(3)],
      };
      const errors = validateForm(values, rules);
      expect(Object.keys(errors)).toHaveLength(0);
    });
  });
});
```

### 6. Barrel Export

#### `src/components/Forms/index.ts`
```typescript
export { default as Input } from './Input';
export type { InputProps } from './Input';

export { default as TextArea } from './TextArea';
export type { TextAreaProps } from './TextArea';

export { default as Select } from './Select';
export type { SelectProps, SelectOption } from './Select';

export { default as FormField } from './FormField';
export type { FormFieldProps } from './FormField';
```

---

## Acceptance Criteria

- [ ] Input component handles all states and sizes
- [ ] TextArea component handles resize options
- [ ] Select component renders options correctly
- [ ] FormField wraps inputs with labels and errors
- [ ] Validation utilities work correctly
- [ ] All components are accessible
- [ ] All tests pass
- [ ] `npm run lint` passes
- [ ] `npm run build` succeeds

---

## On Completion

1. Update `EXECUTION.md`: Mark T007 as `completed`
2. Update `SHARED_NOTES.md` with form usage patterns
3. Commit: `git commit -m "T007: Add form components and validation utilities"`
